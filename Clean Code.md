# Clean Code

## Chapter 3
Reduce complexity of your functions. When functions are large, there's a lot that you have to take in. It means you have more conditions, branches, loops, variables, etc. This makes the function hard to write correctly (error prone) and hard to understand in the future. Smaller functions allow you to treat function calls as a black box: when writing/debugging a single function, you can assume all the other functions are well behaved (returns exactly as advertised). This allows you to focus on the core logic of the current function you are working on and not get distracted by the implementation details of the other functions. This allows the programmer to divide complicated logic into simpler pieces and conquer them one piece at a time.

An additional benefit of breaking down large functions into smaller logical pieces is that it provides easier error handling and testing. For example, you can isolate testing for larger functions by mocking the return data of the functions it calls. Additionally, each function can perform their own error handling which means, for the most part, keeps the code responsible for handling errors concise as well. We've had bugs before where the code handling an exception throws an other exception.

However, I think Bob often goes a little overboard with some of his suggestions, and the suggestion that if/else/for blocks should be just function calls is one of these suggestions. There's a balance abstraction between highly readable code and mindless textbook abstraction code. It's our job as programmers to learn from our experience and find that balance. My opinion is that good code should read like pseudo-code. You can show it to a non-programmer, and they should be able to quickly understand what it's doing (at least for high level programming languages. Plebs will never speak assembly).

Another interesting point in this chapter is the function parameters. I think in our case, especially since we use typescript, it makes sense for the parameters to many functions to be a type. Instead of having a collection of Room data as input, maybe it should take a Room object instead. Better yet, we might want to make it a method for the Room class, and, perhaps, it might not even need to be a public function (which reduces complexity).

One example is the password verification function that checks is a password matches a given pycrypto style PBKDF2 hash. This required lots of parsing, encoding, and calculating hashes, which, if put in just on function, would be a monstrosity. I tried to break it down into easily understandable functions with helpful names as much as possible. Additionally, many of the helpers where written as inner functions of verifyPassword, since their logic is unlikely to be needed anywhere else.`
